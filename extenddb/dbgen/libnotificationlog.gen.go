// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dbgen

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"GINOWEN/extenddb/model"
)

func newLibnotificationlog(db *gorm.DB) libnotificationlog {
	_libnotificationlog := libnotificationlog{}

	_libnotificationlog.libnotificationlogDo.UseDB(db)
	_libnotificationlog.libnotificationlogDo.UseModel(&model.Libnotificationlog{})

	tableName := _libnotificationlog.libnotificationlogDo.TableName()
	_libnotificationlog.ALL = field.NewAsterisk(tableName)
	_libnotificationlog.ID = field.NewString(tableName, "Id")
	_libnotificationlog.CreationTime = field.NewTime(tableName, "CreationTime")
	_libnotificationlog.CreatorUserID = field.NewInt64(tableName, "CreatorUserId")
	_libnotificationlog.TerminalID = field.NewString(tableName, "TerminalId")
	_libnotificationlog.TerminalCode = field.NewString(tableName, "TerminalCode")
	_libnotificationlog.TerminalName = field.NewString(tableName, "TerminalName")
	_libnotificationlog.PatronID = field.NewString(tableName, "PatronId")
	_libnotificationlog.PatronName = field.NewString(tableName, "PatronName")
	_libnotificationlog.PatronBarcode = field.NewString(tableName, "PatronBarcode")
	_libnotificationlog.SendTo = field.NewString(tableName, "SendTo")
	_libnotificationlog.NotificationType = field.NewInt64(tableName, "NotificationType")
	_libnotificationlog.Content = field.NewString(tableName, "Content")
	_libnotificationlog.Result = field.NewInt64(tableName, "Result")
	_libnotificationlog.ErrorMessage = field.NewString(tableName, "ErrorMessage")
	_libnotificationlog.Remark = field.NewString(tableName, "Remark")
	_libnotificationlog.OriginType = field.NewInt64(tableName, "OriginType")
	_libnotificationlog.TenantID = field.NewInt64(tableName, "TenantId")

	_libnotificationlog.fillFieldMap()

	return _libnotificationlog
}

type libnotificationlog struct {
	libnotificationlogDo libnotificationlogDo

	ALL              field.Asterisk
	ID               field.String
	CreationTime     field.Time
	CreatorUserID    field.Int64
	TerminalID       field.String
	TerminalCode     field.String
	TerminalName     field.String
	PatronID         field.String
	PatronName       field.String
	PatronBarcode    field.String
	SendTo           field.String
	NotificationType field.Int64
	Content          field.String
	Result           field.Int64
	ErrorMessage     field.String
	Remark           field.String
	OriginType       field.Int64
	TenantID         field.Int64

	fieldMap map[string]field.Expr
}

func (l libnotificationlog) Table(newTableName string) *libnotificationlog {
	l.libnotificationlogDo.UseTable(newTableName)
	return l.updateTableName(newTableName)
}

func (l libnotificationlog) As(alias string) *libnotificationlog {
	l.libnotificationlogDo.DO = *(l.libnotificationlogDo.As(alias).(*gen.DO))
	return l.updateTableName(alias)
}

func (l *libnotificationlog) updateTableName(table string) *libnotificationlog {
	l.ALL = field.NewAsterisk(table)
	l.ID = field.NewString(table, "Id")
	l.CreationTime = field.NewTime(table, "CreationTime")
	l.CreatorUserID = field.NewInt64(table, "CreatorUserId")
	l.TerminalID = field.NewString(table, "TerminalId")
	l.TerminalCode = field.NewString(table, "TerminalCode")
	l.TerminalName = field.NewString(table, "TerminalName")
	l.PatronID = field.NewString(table, "PatronId")
	l.PatronName = field.NewString(table, "PatronName")
	l.PatronBarcode = field.NewString(table, "PatronBarcode")
	l.SendTo = field.NewString(table, "SendTo")
	l.NotificationType = field.NewInt64(table, "NotificationType")
	l.Content = field.NewString(table, "Content")
	l.Result = field.NewInt64(table, "Result")
	l.ErrorMessage = field.NewString(table, "ErrorMessage")
	l.Remark = field.NewString(table, "Remark")
	l.OriginType = field.NewInt64(table, "OriginType")
	l.TenantID = field.NewInt64(table, "TenantId")

	l.fillFieldMap()

	return l
}

func (l *libnotificationlog) WithContext(ctx context.Context) ILibnotificationlogDo {
	return l.libnotificationlogDo.WithContext(ctx)
}

func (l libnotificationlog) TableName() string { return l.libnotificationlogDo.TableName() }

func (l libnotificationlog) Alias() string { return l.libnotificationlogDo.Alias() }

func (l *libnotificationlog) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := l.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (l *libnotificationlog) fillFieldMap() {
	l.fieldMap = make(map[string]field.Expr, 17)
	l.fieldMap["Id"] = l.ID
	l.fieldMap["CreationTime"] = l.CreationTime
	l.fieldMap["CreatorUserId"] = l.CreatorUserID
	l.fieldMap["TerminalId"] = l.TerminalID
	l.fieldMap["TerminalCode"] = l.TerminalCode
	l.fieldMap["TerminalName"] = l.TerminalName
	l.fieldMap["PatronId"] = l.PatronID
	l.fieldMap["PatronName"] = l.PatronName
	l.fieldMap["PatronBarcode"] = l.PatronBarcode
	l.fieldMap["SendTo"] = l.SendTo
	l.fieldMap["NotificationType"] = l.NotificationType
	l.fieldMap["Content"] = l.Content
	l.fieldMap["Result"] = l.Result
	l.fieldMap["ErrorMessage"] = l.ErrorMessage
	l.fieldMap["Remark"] = l.Remark
	l.fieldMap["OriginType"] = l.OriginType
	l.fieldMap["TenantId"] = l.TenantID
}

func (l libnotificationlog) clone(db *gorm.DB) libnotificationlog {
	l.libnotificationlogDo.ReplaceDB(db)
	return l
}

type libnotificationlogDo struct{ gen.DO }

type ILibnotificationlogDo interface {
	gen.SubQuery
	Debug() ILibnotificationlogDo
	WithContext(ctx context.Context) ILibnotificationlogDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	As(alias string) gen.Dao
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ILibnotificationlogDo
	Not(conds ...gen.Condition) ILibnotificationlogDo
	Or(conds ...gen.Condition) ILibnotificationlogDo
	Select(conds ...field.Expr) ILibnotificationlogDo
	Where(conds ...gen.Condition) ILibnotificationlogDo
	Order(conds ...field.Expr) ILibnotificationlogDo
	Distinct(cols ...field.Expr) ILibnotificationlogDo
	Omit(cols ...field.Expr) ILibnotificationlogDo
	Join(table schema.Tabler, on ...field.Expr) ILibnotificationlogDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ILibnotificationlogDo
	RightJoin(table schema.Tabler, on ...field.Expr) ILibnotificationlogDo
	Group(cols ...field.Expr) ILibnotificationlogDo
	Having(conds ...gen.Condition) ILibnotificationlogDo
	Limit(limit int) ILibnotificationlogDo
	Offset(offset int) ILibnotificationlogDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ILibnotificationlogDo
	Unscoped() ILibnotificationlogDo
	Create(values ...*model.Libnotificationlog) error
	CreateInBatches(values []*model.Libnotificationlog, batchSize int) error
	Save(values ...*model.Libnotificationlog) error
	First() (*model.Libnotificationlog, error)
	Take() (*model.Libnotificationlog, error)
	Last() (*model.Libnotificationlog, error)
	Find() ([]*model.Libnotificationlog, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Libnotificationlog, err error)
	FindInBatches(result *[]*model.Libnotificationlog, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.Libnotificationlog) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ILibnotificationlogDo
	Assign(attrs ...field.AssignExpr) ILibnotificationlogDo
	Joins(fields ...field.RelationField) ILibnotificationlogDo
	Preload(fields ...field.RelationField) ILibnotificationlogDo
	FirstOrInit() (*model.Libnotificationlog, error)
	FirstOrCreate() (*model.Libnotificationlog, error)
	FindByPage(offset int, limit int) (result []*model.Libnotificationlog, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ILibnotificationlogDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (l libnotificationlogDo) Debug() ILibnotificationlogDo {
	return l.withDO(l.DO.Debug())
}

func (l libnotificationlogDo) WithContext(ctx context.Context) ILibnotificationlogDo {
	return l.withDO(l.DO.WithContext(ctx))
}

func (l libnotificationlogDo) ReadDB() ILibnotificationlogDo {
	return l.Clauses(dbresolver.Read)
}

func (l libnotificationlogDo) WriteDB() ILibnotificationlogDo {
	return l.Clauses(dbresolver.Write)
}

func (l libnotificationlogDo) Clauses(conds ...clause.Expression) ILibnotificationlogDo {
	return l.withDO(l.DO.Clauses(conds...))
}

func (l libnotificationlogDo) Returning(value interface{}, columns ...string) ILibnotificationlogDo {
	return l.withDO(l.DO.Returning(value, columns...))
}

func (l libnotificationlogDo) Not(conds ...gen.Condition) ILibnotificationlogDo {
	return l.withDO(l.DO.Not(conds...))
}

func (l libnotificationlogDo) Or(conds ...gen.Condition) ILibnotificationlogDo {
	return l.withDO(l.DO.Or(conds...))
}

func (l libnotificationlogDo) Select(conds ...field.Expr) ILibnotificationlogDo {
	return l.withDO(l.DO.Select(conds...))
}

func (l libnotificationlogDo) Where(conds ...gen.Condition) ILibnotificationlogDo {
	return l.withDO(l.DO.Where(conds...))
}

func (l libnotificationlogDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) ILibnotificationlogDo {
	return l.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (l libnotificationlogDo) Order(conds ...field.Expr) ILibnotificationlogDo {
	return l.withDO(l.DO.Order(conds...))
}

func (l libnotificationlogDo) Distinct(cols ...field.Expr) ILibnotificationlogDo {
	return l.withDO(l.DO.Distinct(cols...))
}

func (l libnotificationlogDo) Omit(cols ...field.Expr) ILibnotificationlogDo {
	return l.withDO(l.DO.Omit(cols...))
}

func (l libnotificationlogDo) Join(table schema.Tabler, on ...field.Expr) ILibnotificationlogDo {
	return l.withDO(l.DO.Join(table, on...))
}

func (l libnotificationlogDo) LeftJoin(table schema.Tabler, on ...field.Expr) ILibnotificationlogDo {
	return l.withDO(l.DO.LeftJoin(table, on...))
}

func (l libnotificationlogDo) RightJoin(table schema.Tabler, on ...field.Expr) ILibnotificationlogDo {
	return l.withDO(l.DO.RightJoin(table, on...))
}

func (l libnotificationlogDo) Group(cols ...field.Expr) ILibnotificationlogDo {
	return l.withDO(l.DO.Group(cols...))
}

func (l libnotificationlogDo) Having(conds ...gen.Condition) ILibnotificationlogDo {
	return l.withDO(l.DO.Having(conds...))
}

func (l libnotificationlogDo) Limit(limit int) ILibnotificationlogDo {
	return l.withDO(l.DO.Limit(limit))
}

func (l libnotificationlogDo) Offset(offset int) ILibnotificationlogDo {
	return l.withDO(l.DO.Offset(offset))
}

func (l libnotificationlogDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ILibnotificationlogDo {
	return l.withDO(l.DO.Scopes(funcs...))
}

func (l libnotificationlogDo) Unscoped() ILibnotificationlogDo {
	return l.withDO(l.DO.Unscoped())
}

func (l libnotificationlogDo) Create(values ...*model.Libnotificationlog) error {
	if len(values) == 0 {
		return nil
	}
	return l.DO.Create(values)
}

func (l libnotificationlogDo) CreateInBatches(values []*model.Libnotificationlog, batchSize int) error {
	return l.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (l libnotificationlogDo) Save(values ...*model.Libnotificationlog) error {
	if len(values) == 0 {
		return nil
	}
	return l.DO.Save(values)
}

func (l libnotificationlogDo) First() (*model.Libnotificationlog, error) {
	if result, err := l.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.Libnotificationlog), nil
	}
}

func (l libnotificationlogDo) Take() (*model.Libnotificationlog, error) {
	if result, err := l.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.Libnotificationlog), nil
	}
}

func (l libnotificationlogDo) Last() (*model.Libnotificationlog, error) {
	if result, err := l.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.Libnotificationlog), nil
	}
}

func (l libnotificationlogDo) Find() ([]*model.Libnotificationlog, error) {
	result, err := l.DO.Find()
	return result.([]*model.Libnotificationlog), err
}

func (l libnotificationlogDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Libnotificationlog, err error) {
	buf := make([]*model.Libnotificationlog, 0, batchSize)
	err = l.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (l libnotificationlogDo) FindInBatches(result *[]*model.Libnotificationlog, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return l.DO.FindInBatches(result, batchSize, fc)
}

func (l libnotificationlogDo) Attrs(attrs ...field.AssignExpr) ILibnotificationlogDo {
	return l.withDO(l.DO.Attrs(attrs...))
}

func (l libnotificationlogDo) Assign(attrs ...field.AssignExpr) ILibnotificationlogDo {
	return l.withDO(l.DO.Assign(attrs...))
}

func (l libnotificationlogDo) Joins(fields ...field.RelationField) ILibnotificationlogDo {
	for _, _f := range fields {
		l = *l.withDO(l.DO.Joins(_f))
	}
	return &l
}

func (l libnotificationlogDo) Preload(fields ...field.RelationField) ILibnotificationlogDo {
	for _, _f := range fields {
		l = *l.withDO(l.DO.Preload(_f))
	}
	return &l
}

func (l libnotificationlogDo) FirstOrInit() (*model.Libnotificationlog, error) {
	if result, err := l.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.Libnotificationlog), nil
	}
}

func (l libnotificationlogDo) FirstOrCreate() (*model.Libnotificationlog, error) {
	if result, err := l.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.Libnotificationlog), nil
	}
}

func (l libnotificationlogDo) FindByPage(offset int, limit int) (result []*model.Libnotificationlog, count int64, err error) {
	result, err = l.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = l.Offset(-1).Limit(-1).Count()
	return
}

func (l libnotificationlogDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = l.Count()
	if err != nil {
		return
	}

	err = l.Offset(offset).Limit(limit).Scan(result)
	return
}

func (l libnotificationlogDo) Scan(result interface{}) (err error) {
	return l.DO.Scan(result)
}

func (l libnotificationlogDo) Delete(models ...*model.Libnotificationlog) (result gen.ResultInfo, err error) {
	return l.DO.Delete(models)
}

func (l *libnotificationlogDo) withDO(do gen.Dao) *libnotificationlogDo {
	l.DO = *do.(*gen.DO)
	return l
}
