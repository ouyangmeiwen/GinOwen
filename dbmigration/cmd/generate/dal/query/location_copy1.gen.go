// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"gormgendemo/cmd/generate/dal/model"
)

func newLocationCopy1(db *gorm.DB) locationCopy1 {
	_locationCopy1 := locationCopy1{}

	_locationCopy1.locationCopy1Do.UseDB(db)
	_locationCopy1.locationCopy1Do.UseModel(&model.LocationCopy1{})

	tableName := _locationCopy1.locationCopy1Do.TableName()
	_locationCopy1.ALL = field.NewAsterisk(tableName)
	_locationCopy1.LOCATIONID = field.NewInt64(tableName, "LOCATION_ID")
	_locationCopy1.LOCATIONCODE = field.NewString(tableName, "LOCATION_CODE")
	_locationCopy1.LOCATIONNAME = field.NewString(tableName, "LOCATION_NAME")
	_locationCopy1.LOCATIONTYPECODE = field.NewString(tableName, "LOCATION_TYPE_CODE")
	_locationCopy1.ADDRESS = field.NewString(tableName, "ADDRESS")
	_locationCopy1.INTRODUCE = field.NewString(tableName, "INTRODUCE")
	_locationCopy1.LOCATIONCLASS = field.NewString(tableName, "LOCATION_CLASS")
	_locationCopy1.CIRCATTR = field.NewInt64(tableName, "CIRC_ATTR")
	_locationCopy1.REMARK = field.NewString(tableName, "REMARK")
	_locationCopy1.USEFLAG = field.NewString(tableName, "USE_FLAG")
	_locationCopy1.LIBCODE = field.NewString(tableName, "LIB_CODE")
	_locationCopy1.BRANCHCODE = field.NewString(tableName, "BRANCH_CODE")
	_locationCopy1.GROUPCODE = field.NewString(tableName, "GROUP_CODE")
	_locationCopy1.CREATEBY = field.NewInt64(tableName, "CREATE_BY")
	_locationCopy1.CREATEDATE = field.NewTime(tableName, "CREATE_DATE")
	_locationCopy1.UPDATEBY = field.NewInt64(tableName, "UPDATE_BY")
	_locationCopy1.UPDATEDATE = field.NewTime(tableName, "UPDATE_DATE")
	_locationCopy1.OPENFLAG = field.NewString(tableName, "OPEN_FLAG")
	_locationCopy1.LOCATIONSHORTNAME = field.NewString(tableName, "LOCATION_SHORT_NAME")
	_locationCopy1.CAMPUSID = field.NewInt64(tableName, "CAMPUS_ID")
	_locationCopy1.ORDERTAKEBOOKFLAG = field.NewString(tableName, "ORDER_TAKE_BOOK_FLAG")
	_locationCopy1.TAKEBOOKFLAG = field.NewString(tableName, "TAKE_BOOK_FLAG")
	_locationCopy1.OFFERENTRUSTSERVICE = field.NewString(tableName, "OFFER_ENTRUST_SERVICE")
	_locationCopy1.OFFERRESERVESERVICE = field.NewString(tableName, "OFFER_RESERVE_SERVICE")
	_locationCopy1.FINDSHOWFLAG = field.NewInt64(tableName, "FIND_SHOW_FLAG")
	_locationCopy1.ENTRUSTTAKEBOOKLIMIT = field.NewString(tableName, "ENTRUST_TAKE_BOOK_LIMIT")
	_locationCopy1.ONSHELFTYPE = field.NewString(tableName, "ON_SHELF_TYPE")
	_locationCopy1.DELAYDAYS = field.NewInt64(tableName, "DELAY_DAYS")
	_locationCopy1.RETURNBOOKSHELFTYPE = field.NewString(tableName, "RETURN_BOOKSHELF_TYPE")
	_locationCopy1.SORT = field.NewInt64(tableName, "SORT")
	_locationCopy1.ISINTENSIVE = field.NewString(tableName, "IS_INTENSIVE")
	_locationCopy1.COUNTERSHOWFLAG = field.NewString(tableName, "COUNTER_SHOW_FLAG")
	_locationCopy1.MAXLENDCOUNT = field.NewInt64(tableName, "MAX_LEND_COUNT")
	_locationCopy1.COUNTERSORT = field.NewInt64(tableName, "COUNTER_SORT")

	_locationCopy1.fillFieldMap()

	return _locationCopy1
}

type locationCopy1 struct {
	locationCopy1Do locationCopy1Do

	ALL                  field.Asterisk
	LOCATIONID           field.Int64
	LOCATIONCODE         field.String
	LOCATIONNAME         field.String
	LOCATIONTYPECODE     field.String
	ADDRESS              field.String
	INTRODUCE            field.String
	LOCATIONCLASS        field.String
	CIRCATTR             field.Int64
	REMARK               field.String
	USEFLAG              field.String
	LIBCODE              field.String
	BRANCHCODE           field.String
	GROUPCODE            field.String
	CREATEBY             field.Int64
	CREATEDATE           field.Time // 创建时间
	UPDATEBY             field.Int64
	UPDATEDATE           field.Time // 更新时间
	OPENFLAG             field.String
	LOCATIONSHORTNAME    field.String
	CAMPUSID             field.Int64
	ORDERTAKEBOOKFLAG    field.String // 是否预约取书地（0 ：否 1：是）
	TAKEBOOKFLAG         field.String
	OFFERENTRUSTSERVICE  field.String
	OFFERRESERVESERVICE  field.String
	FINDSHOWFLAG         field.Int64  // 统一检索是否展示馆藏地标记 0不展示 1展示
	ENTRUSTTAKEBOOKLIMIT field.String // 委托取书地限制(0: 不限制   1: 限制本校区/地区取书   2: 限制异校区/地区取书)
	ONSHELFTYPE          field.String // (废弃)新书上架类型 1:立即上架 2:手动上架 3:分配n天后自动上架
	DELAYDAYS            field.Int64  // (废弃)延迟上架天数
	RETURNBOOKSHELFTYPE  field.String // 还书上架类型 1:立即上架 2:手动上架
	SORT                 field.Int64  // 馆藏地排序字段
	ISINTENSIVE          field.String // 是否为密集库 0不是 1是 默认为0
	COUNTERSHOWFLAG      field.String // 分析决策展示标识 0不展示 1展示
	MAXLENDCOUNT         field.Int64  // 最大借阅复本数
	COUNTERSORT          field.Int64  // 馆藏地分析决策排序字段

	fieldMap map[string]field.Expr
}

func (l locationCopy1) Table(newTableName string) *locationCopy1 {
	l.locationCopy1Do.UseTable(newTableName)
	return l.updateTableName(newTableName)
}

func (l locationCopy1) As(alias string) *locationCopy1 {
	l.locationCopy1Do.DO = *(l.locationCopy1Do.As(alias).(*gen.DO))
	return l.updateTableName(alias)
}

func (l *locationCopy1) updateTableName(table string) *locationCopy1 {
	l.ALL = field.NewAsterisk(table)
	l.LOCATIONID = field.NewInt64(table, "LOCATION_ID")
	l.LOCATIONCODE = field.NewString(table, "LOCATION_CODE")
	l.LOCATIONNAME = field.NewString(table, "LOCATION_NAME")
	l.LOCATIONTYPECODE = field.NewString(table, "LOCATION_TYPE_CODE")
	l.ADDRESS = field.NewString(table, "ADDRESS")
	l.INTRODUCE = field.NewString(table, "INTRODUCE")
	l.LOCATIONCLASS = field.NewString(table, "LOCATION_CLASS")
	l.CIRCATTR = field.NewInt64(table, "CIRC_ATTR")
	l.REMARK = field.NewString(table, "REMARK")
	l.USEFLAG = field.NewString(table, "USE_FLAG")
	l.LIBCODE = field.NewString(table, "LIB_CODE")
	l.BRANCHCODE = field.NewString(table, "BRANCH_CODE")
	l.GROUPCODE = field.NewString(table, "GROUP_CODE")
	l.CREATEBY = field.NewInt64(table, "CREATE_BY")
	l.CREATEDATE = field.NewTime(table, "CREATE_DATE")
	l.UPDATEBY = field.NewInt64(table, "UPDATE_BY")
	l.UPDATEDATE = field.NewTime(table, "UPDATE_DATE")
	l.OPENFLAG = field.NewString(table, "OPEN_FLAG")
	l.LOCATIONSHORTNAME = field.NewString(table, "LOCATION_SHORT_NAME")
	l.CAMPUSID = field.NewInt64(table, "CAMPUS_ID")
	l.ORDERTAKEBOOKFLAG = field.NewString(table, "ORDER_TAKE_BOOK_FLAG")
	l.TAKEBOOKFLAG = field.NewString(table, "TAKE_BOOK_FLAG")
	l.OFFERENTRUSTSERVICE = field.NewString(table, "OFFER_ENTRUST_SERVICE")
	l.OFFERRESERVESERVICE = field.NewString(table, "OFFER_RESERVE_SERVICE")
	l.FINDSHOWFLAG = field.NewInt64(table, "FIND_SHOW_FLAG")
	l.ENTRUSTTAKEBOOKLIMIT = field.NewString(table, "ENTRUST_TAKE_BOOK_LIMIT")
	l.ONSHELFTYPE = field.NewString(table, "ON_SHELF_TYPE")
	l.DELAYDAYS = field.NewInt64(table, "DELAY_DAYS")
	l.RETURNBOOKSHELFTYPE = field.NewString(table, "RETURN_BOOKSHELF_TYPE")
	l.SORT = field.NewInt64(table, "SORT")
	l.ISINTENSIVE = field.NewString(table, "IS_INTENSIVE")
	l.COUNTERSHOWFLAG = field.NewString(table, "COUNTER_SHOW_FLAG")
	l.MAXLENDCOUNT = field.NewInt64(table, "MAX_LEND_COUNT")
	l.COUNTERSORT = field.NewInt64(table, "COUNTER_SORT")

	l.fillFieldMap()

	return l
}

func (l *locationCopy1) WithContext(ctx context.Context) ILocationCopy1Do {
	return l.locationCopy1Do.WithContext(ctx)
}

func (l locationCopy1) TableName() string { return l.locationCopy1Do.TableName() }

func (l locationCopy1) Alias() string { return l.locationCopy1Do.Alias() }

func (l *locationCopy1) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := l.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (l *locationCopy1) fillFieldMap() {
	l.fieldMap = make(map[string]field.Expr, 34)
	l.fieldMap["LOCATION_ID"] = l.LOCATIONID
	l.fieldMap["LOCATION_CODE"] = l.LOCATIONCODE
	l.fieldMap["LOCATION_NAME"] = l.LOCATIONNAME
	l.fieldMap["LOCATION_TYPE_CODE"] = l.LOCATIONTYPECODE
	l.fieldMap["ADDRESS"] = l.ADDRESS
	l.fieldMap["INTRODUCE"] = l.INTRODUCE
	l.fieldMap["LOCATION_CLASS"] = l.LOCATIONCLASS
	l.fieldMap["CIRC_ATTR"] = l.CIRCATTR
	l.fieldMap["REMARK"] = l.REMARK
	l.fieldMap["USE_FLAG"] = l.USEFLAG
	l.fieldMap["LIB_CODE"] = l.LIBCODE
	l.fieldMap["BRANCH_CODE"] = l.BRANCHCODE
	l.fieldMap["GROUP_CODE"] = l.GROUPCODE
	l.fieldMap["CREATE_BY"] = l.CREATEBY
	l.fieldMap["CREATE_DATE"] = l.CREATEDATE
	l.fieldMap["UPDATE_BY"] = l.UPDATEBY
	l.fieldMap["UPDATE_DATE"] = l.UPDATEDATE
	l.fieldMap["OPEN_FLAG"] = l.OPENFLAG
	l.fieldMap["LOCATION_SHORT_NAME"] = l.LOCATIONSHORTNAME
	l.fieldMap["CAMPUS_ID"] = l.CAMPUSID
	l.fieldMap["ORDER_TAKE_BOOK_FLAG"] = l.ORDERTAKEBOOKFLAG
	l.fieldMap["TAKE_BOOK_FLAG"] = l.TAKEBOOKFLAG
	l.fieldMap["OFFER_ENTRUST_SERVICE"] = l.OFFERENTRUSTSERVICE
	l.fieldMap["OFFER_RESERVE_SERVICE"] = l.OFFERRESERVESERVICE
	l.fieldMap["FIND_SHOW_FLAG"] = l.FINDSHOWFLAG
	l.fieldMap["ENTRUST_TAKE_BOOK_LIMIT"] = l.ENTRUSTTAKEBOOKLIMIT
	l.fieldMap["ON_SHELF_TYPE"] = l.ONSHELFTYPE
	l.fieldMap["DELAY_DAYS"] = l.DELAYDAYS
	l.fieldMap["RETURN_BOOKSHELF_TYPE"] = l.RETURNBOOKSHELFTYPE
	l.fieldMap["SORT"] = l.SORT
	l.fieldMap["IS_INTENSIVE"] = l.ISINTENSIVE
	l.fieldMap["COUNTER_SHOW_FLAG"] = l.COUNTERSHOWFLAG
	l.fieldMap["MAX_LEND_COUNT"] = l.MAXLENDCOUNT
	l.fieldMap["COUNTER_SORT"] = l.COUNTERSORT
}

func (l locationCopy1) clone(db *gorm.DB) locationCopy1 {
	l.locationCopy1Do.ReplaceDB(db)
	return l
}

type locationCopy1Do struct{ gen.DO }

type ILocationCopy1Do interface {
	gen.SubQuery
	Debug() ILocationCopy1Do
	WithContext(ctx context.Context) ILocationCopy1Do
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	As(alias string) gen.Dao
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ILocationCopy1Do
	Not(conds ...gen.Condition) ILocationCopy1Do
	Or(conds ...gen.Condition) ILocationCopy1Do
	Select(conds ...field.Expr) ILocationCopy1Do
	Where(conds ...gen.Condition) ILocationCopy1Do
	Order(conds ...field.Expr) ILocationCopy1Do
	Distinct(cols ...field.Expr) ILocationCopy1Do
	Omit(cols ...field.Expr) ILocationCopy1Do
	Join(table schema.Tabler, on ...field.Expr) ILocationCopy1Do
	LeftJoin(table schema.Tabler, on ...field.Expr) ILocationCopy1Do
	RightJoin(table schema.Tabler, on ...field.Expr) ILocationCopy1Do
	Group(cols ...field.Expr) ILocationCopy1Do
	Having(conds ...gen.Condition) ILocationCopy1Do
	Limit(limit int) ILocationCopy1Do
	Offset(offset int) ILocationCopy1Do
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ILocationCopy1Do
	Unscoped() ILocationCopy1Do
	Create(values ...*model.LocationCopy1) error
	CreateInBatches(values []*model.LocationCopy1, batchSize int) error
	Save(values ...*model.LocationCopy1) error
	First() (*model.LocationCopy1, error)
	Take() (*model.LocationCopy1, error)
	Last() (*model.LocationCopy1, error)
	Find() ([]*model.LocationCopy1, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.LocationCopy1, err error)
	FindInBatches(result *[]*model.LocationCopy1, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.LocationCopy1) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ILocationCopy1Do
	Assign(attrs ...field.AssignExpr) ILocationCopy1Do
	Joins(fields ...field.RelationField) ILocationCopy1Do
	Preload(fields ...field.RelationField) ILocationCopy1Do
	FirstOrInit() (*model.LocationCopy1, error)
	FirstOrCreate() (*model.LocationCopy1, error)
	FindByPage(offset int, limit int) (result []*model.LocationCopy1, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ILocationCopy1Do
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (l locationCopy1Do) Debug() ILocationCopy1Do {
	return l.withDO(l.DO.Debug())
}

func (l locationCopy1Do) WithContext(ctx context.Context) ILocationCopy1Do {
	return l.withDO(l.DO.WithContext(ctx))
}

func (l locationCopy1Do) ReadDB() ILocationCopy1Do {
	return l.Clauses(dbresolver.Read)
}

func (l locationCopy1Do) WriteDB() ILocationCopy1Do {
	return l.Clauses(dbresolver.Write)
}

func (l locationCopy1Do) Clauses(conds ...clause.Expression) ILocationCopy1Do {
	return l.withDO(l.DO.Clauses(conds...))
}

func (l locationCopy1Do) Returning(value interface{}, columns ...string) ILocationCopy1Do {
	return l.withDO(l.DO.Returning(value, columns...))
}

func (l locationCopy1Do) Not(conds ...gen.Condition) ILocationCopy1Do {
	return l.withDO(l.DO.Not(conds...))
}

func (l locationCopy1Do) Or(conds ...gen.Condition) ILocationCopy1Do {
	return l.withDO(l.DO.Or(conds...))
}

func (l locationCopy1Do) Select(conds ...field.Expr) ILocationCopy1Do {
	return l.withDO(l.DO.Select(conds...))
}

func (l locationCopy1Do) Where(conds ...gen.Condition) ILocationCopy1Do {
	return l.withDO(l.DO.Where(conds...))
}

func (l locationCopy1Do) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) ILocationCopy1Do {
	return l.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (l locationCopy1Do) Order(conds ...field.Expr) ILocationCopy1Do {
	return l.withDO(l.DO.Order(conds...))
}

func (l locationCopy1Do) Distinct(cols ...field.Expr) ILocationCopy1Do {
	return l.withDO(l.DO.Distinct(cols...))
}

func (l locationCopy1Do) Omit(cols ...field.Expr) ILocationCopy1Do {
	return l.withDO(l.DO.Omit(cols...))
}

func (l locationCopy1Do) Join(table schema.Tabler, on ...field.Expr) ILocationCopy1Do {
	return l.withDO(l.DO.Join(table, on...))
}

func (l locationCopy1Do) LeftJoin(table schema.Tabler, on ...field.Expr) ILocationCopy1Do {
	return l.withDO(l.DO.LeftJoin(table, on...))
}

func (l locationCopy1Do) RightJoin(table schema.Tabler, on ...field.Expr) ILocationCopy1Do {
	return l.withDO(l.DO.RightJoin(table, on...))
}

func (l locationCopy1Do) Group(cols ...field.Expr) ILocationCopy1Do {
	return l.withDO(l.DO.Group(cols...))
}

func (l locationCopy1Do) Having(conds ...gen.Condition) ILocationCopy1Do {
	return l.withDO(l.DO.Having(conds...))
}

func (l locationCopy1Do) Limit(limit int) ILocationCopy1Do {
	return l.withDO(l.DO.Limit(limit))
}

func (l locationCopy1Do) Offset(offset int) ILocationCopy1Do {
	return l.withDO(l.DO.Offset(offset))
}

func (l locationCopy1Do) Scopes(funcs ...func(gen.Dao) gen.Dao) ILocationCopy1Do {
	return l.withDO(l.DO.Scopes(funcs...))
}

func (l locationCopy1Do) Unscoped() ILocationCopy1Do {
	return l.withDO(l.DO.Unscoped())
}

func (l locationCopy1Do) Create(values ...*model.LocationCopy1) error {
	if len(values) == 0 {
		return nil
	}
	return l.DO.Create(values)
}

func (l locationCopy1Do) CreateInBatches(values []*model.LocationCopy1, batchSize int) error {
	return l.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (l locationCopy1Do) Save(values ...*model.LocationCopy1) error {
	if len(values) == 0 {
		return nil
	}
	return l.DO.Save(values)
}

func (l locationCopy1Do) First() (*model.LocationCopy1, error) {
	if result, err := l.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.LocationCopy1), nil
	}
}

func (l locationCopy1Do) Take() (*model.LocationCopy1, error) {
	if result, err := l.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.LocationCopy1), nil
	}
}

func (l locationCopy1Do) Last() (*model.LocationCopy1, error) {
	if result, err := l.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.LocationCopy1), nil
	}
}

func (l locationCopy1Do) Find() ([]*model.LocationCopy1, error) {
	result, err := l.DO.Find()
	return result.([]*model.LocationCopy1), err
}

func (l locationCopy1Do) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.LocationCopy1, err error) {
	buf := make([]*model.LocationCopy1, 0, batchSize)
	err = l.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (l locationCopy1Do) FindInBatches(result *[]*model.LocationCopy1, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return l.DO.FindInBatches(result, batchSize, fc)
}

func (l locationCopy1Do) Attrs(attrs ...field.AssignExpr) ILocationCopy1Do {
	return l.withDO(l.DO.Attrs(attrs...))
}

func (l locationCopy1Do) Assign(attrs ...field.AssignExpr) ILocationCopy1Do {
	return l.withDO(l.DO.Assign(attrs...))
}

func (l locationCopy1Do) Joins(fields ...field.RelationField) ILocationCopy1Do {
	for _, _f := range fields {
		l = *l.withDO(l.DO.Joins(_f))
	}
	return &l
}

func (l locationCopy1Do) Preload(fields ...field.RelationField) ILocationCopy1Do {
	for _, _f := range fields {
		l = *l.withDO(l.DO.Preload(_f))
	}
	return &l
}

func (l locationCopy1Do) FirstOrInit() (*model.LocationCopy1, error) {
	if result, err := l.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.LocationCopy1), nil
	}
}

func (l locationCopy1Do) FirstOrCreate() (*model.LocationCopy1, error) {
	if result, err := l.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.LocationCopy1), nil
	}
}

func (l locationCopy1Do) FindByPage(offset int, limit int) (result []*model.LocationCopy1, count int64, err error) {
	result, err = l.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = l.Offset(-1).Limit(-1).Count()
	return
}

func (l locationCopy1Do) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = l.Count()
	if err != nil {
		return
	}

	err = l.Offset(offset).Limit(limit).Scan(result)
	return
}

func (l locationCopy1Do) Scan(result interface{}) (err error) {
	return l.DO.Scan(result)
}

func (l locationCopy1Do) Delete(models ...*model.LocationCopy1) (result gen.ResultInfo, err error) {
	return l.DO.Delete(models)
}

func (l *locationCopy1Do) withDO(do gen.Dao) *locationCopy1Do {
	l.DO = *do.(*gen.DO)
	return l
}
