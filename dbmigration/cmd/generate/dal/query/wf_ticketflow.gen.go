// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"gormgendemo/cmd/generate/dal/model"
)

func newWfTicketflow(db *gorm.DB) wfTicketflow {
	_wfTicketflow := wfTicketflow{}

	_wfTicketflow.wfTicketflowDo.UseDB(db)
	_wfTicketflow.wfTicketflowDo.UseModel(&model.WfTicketflow{})

	tableName := _wfTicketflow.wfTicketflowDo.TableName()
	_wfTicketflow.ALL = field.NewAsterisk(tableName)
	_wfTicketflow.ID = field.NewInt64(tableName, "id")
	_wfTicketflow.CreateTime = field.NewTime(tableName, "create_time")
	_wfTicketflow.UpdateTime = field.NewTime(tableName, "update_time")
	_wfTicketflow.IsDeleted = field.NewInt64(tableName, "is_deleted")
	_wfTicketflow.Suggestion = field.NewString(tableName, "suggestion")
	_wfTicketflow.ParticipantType = field.NewInt64(tableName, "participant_type")
	_wfTicketflow.ParticipantStr = field.NewString(tableName, "participant_str")
	_wfTicketflow.TicketData = field.NewString(tableName, "ticket_data")
	_wfTicketflow.InterveneType = field.NewInt64(tableName, "intervene_type")
	_wfTicketflow.ParticipantCc = field.NewString(tableName, "participant_cc")
	_wfTicketflow.ParticipantID = field.NewInt64(tableName, "participant_id")
	_wfTicketflow.StateID = field.NewInt64(tableName, "state_id")
	_wfTicketflow.TicketID = field.NewInt64(tableName, "ticket_id")
	_wfTicketflow.TransitionID = field.NewInt64(tableName, "transition_id")

	_wfTicketflow.fillFieldMap()

	return _wfTicketflow
}

type wfTicketflow struct {
	wfTicketflowDo wfTicketflowDo

	ALL             field.Asterisk
	ID              field.Int64
	CreateTime      field.Time
	UpdateTime      field.Time
	IsDeleted       field.Int64
	Suggestion      field.String
	ParticipantType field.Int64
	ParticipantStr  field.String
	TicketData      field.String
	InterveneType   field.Int64
	ParticipantCc   field.String
	ParticipantID   field.Int64
	StateID         field.Int64
	TicketID        field.Int64
	TransitionID    field.Int64

	fieldMap map[string]field.Expr
}

func (w wfTicketflow) Table(newTableName string) *wfTicketflow {
	w.wfTicketflowDo.UseTable(newTableName)
	return w.updateTableName(newTableName)
}

func (w wfTicketflow) As(alias string) *wfTicketflow {
	w.wfTicketflowDo.DO = *(w.wfTicketflowDo.As(alias).(*gen.DO))
	return w.updateTableName(alias)
}

func (w *wfTicketflow) updateTableName(table string) *wfTicketflow {
	w.ALL = field.NewAsterisk(table)
	w.ID = field.NewInt64(table, "id")
	w.CreateTime = field.NewTime(table, "create_time")
	w.UpdateTime = field.NewTime(table, "update_time")
	w.IsDeleted = field.NewInt64(table, "is_deleted")
	w.Suggestion = field.NewString(table, "suggestion")
	w.ParticipantType = field.NewInt64(table, "participant_type")
	w.ParticipantStr = field.NewString(table, "participant_str")
	w.TicketData = field.NewString(table, "ticket_data")
	w.InterveneType = field.NewInt64(table, "intervene_type")
	w.ParticipantCc = field.NewString(table, "participant_cc")
	w.ParticipantID = field.NewInt64(table, "participant_id")
	w.StateID = field.NewInt64(table, "state_id")
	w.TicketID = field.NewInt64(table, "ticket_id")
	w.TransitionID = field.NewInt64(table, "transition_id")

	w.fillFieldMap()

	return w
}

func (w *wfTicketflow) WithContext(ctx context.Context) IWfTicketflowDo {
	return w.wfTicketflowDo.WithContext(ctx)
}

func (w wfTicketflow) TableName() string { return w.wfTicketflowDo.TableName() }

func (w wfTicketflow) Alias() string { return w.wfTicketflowDo.Alias() }

func (w *wfTicketflow) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := w.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (w *wfTicketflow) fillFieldMap() {
	w.fieldMap = make(map[string]field.Expr, 14)
	w.fieldMap["id"] = w.ID
	w.fieldMap["create_time"] = w.CreateTime
	w.fieldMap["update_time"] = w.UpdateTime
	w.fieldMap["is_deleted"] = w.IsDeleted
	w.fieldMap["suggestion"] = w.Suggestion
	w.fieldMap["participant_type"] = w.ParticipantType
	w.fieldMap["participant_str"] = w.ParticipantStr
	w.fieldMap["ticket_data"] = w.TicketData
	w.fieldMap["intervene_type"] = w.InterveneType
	w.fieldMap["participant_cc"] = w.ParticipantCc
	w.fieldMap["participant_id"] = w.ParticipantID
	w.fieldMap["state_id"] = w.StateID
	w.fieldMap["ticket_id"] = w.TicketID
	w.fieldMap["transition_id"] = w.TransitionID
}

func (w wfTicketflow) clone(db *gorm.DB) wfTicketflow {
	w.wfTicketflowDo.ReplaceDB(db)
	return w
}

type wfTicketflowDo struct{ gen.DO }

type IWfTicketflowDo interface {
	gen.SubQuery
	Debug() IWfTicketflowDo
	WithContext(ctx context.Context) IWfTicketflowDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	As(alias string) gen.Dao
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IWfTicketflowDo
	Not(conds ...gen.Condition) IWfTicketflowDo
	Or(conds ...gen.Condition) IWfTicketflowDo
	Select(conds ...field.Expr) IWfTicketflowDo
	Where(conds ...gen.Condition) IWfTicketflowDo
	Order(conds ...field.Expr) IWfTicketflowDo
	Distinct(cols ...field.Expr) IWfTicketflowDo
	Omit(cols ...field.Expr) IWfTicketflowDo
	Join(table schema.Tabler, on ...field.Expr) IWfTicketflowDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IWfTicketflowDo
	RightJoin(table schema.Tabler, on ...field.Expr) IWfTicketflowDo
	Group(cols ...field.Expr) IWfTicketflowDo
	Having(conds ...gen.Condition) IWfTicketflowDo
	Limit(limit int) IWfTicketflowDo
	Offset(offset int) IWfTicketflowDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IWfTicketflowDo
	Unscoped() IWfTicketflowDo
	Create(values ...*model.WfTicketflow) error
	CreateInBatches(values []*model.WfTicketflow, batchSize int) error
	Save(values ...*model.WfTicketflow) error
	First() (*model.WfTicketflow, error)
	Take() (*model.WfTicketflow, error)
	Last() (*model.WfTicketflow, error)
	Find() ([]*model.WfTicketflow, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.WfTicketflow, err error)
	FindInBatches(result *[]*model.WfTicketflow, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.WfTicketflow) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IWfTicketflowDo
	Assign(attrs ...field.AssignExpr) IWfTicketflowDo
	Joins(fields ...field.RelationField) IWfTicketflowDo
	Preload(fields ...field.RelationField) IWfTicketflowDo
	FirstOrInit() (*model.WfTicketflow, error)
	FirstOrCreate() (*model.WfTicketflow, error)
	FindByPage(offset int, limit int) (result []*model.WfTicketflow, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IWfTicketflowDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (w wfTicketflowDo) Debug() IWfTicketflowDo {
	return w.withDO(w.DO.Debug())
}

func (w wfTicketflowDo) WithContext(ctx context.Context) IWfTicketflowDo {
	return w.withDO(w.DO.WithContext(ctx))
}

func (w wfTicketflowDo) ReadDB() IWfTicketflowDo {
	return w.Clauses(dbresolver.Read)
}

func (w wfTicketflowDo) WriteDB() IWfTicketflowDo {
	return w.Clauses(dbresolver.Write)
}

func (w wfTicketflowDo) Clauses(conds ...clause.Expression) IWfTicketflowDo {
	return w.withDO(w.DO.Clauses(conds...))
}

func (w wfTicketflowDo) Returning(value interface{}, columns ...string) IWfTicketflowDo {
	return w.withDO(w.DO.Returning(value, columns...))
}

func (w wfTicketflowDo) Not(conds ...gen.Condition) IWfTicketflowDo {
	return w.withDO(w.DO.Not(conds...))
}

func (w wfTicketflowDo) Or(conds ...gen.Condition) IWfTicketflowDo {
	return w.withDO(w.DO.Or(conds...))
}

func (w wfTicketflowDo) Select(conds ...field.Expr) IWfTicketflowDo {
	return w.withDO(w.DO.Select(conds...))
}

func (w wfTicketflowDo) Where(conds ...gen.Condition) IWfTicketflowDo {
	return w.withDO(w.DO.Where(conds...))
}

func (w wfTicketflowDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) IWfTicketflowDo {
	return w.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (w wfTicketflowDo) Order(conds ...field.Expr) IWfTicketflowDo {
	return w.withDO(w.DO.Order(conds...))
}

func (w wfTicketflowDo) Distinct(cols ...field.Expr) IWfTicketflowDo {
	return w.withDO(w.DO.Distinct(cols...))
}

func (w wfTicketflowDo) Omit(cols ...field.Expr) IWfTicketflowDo {
	return w.withDO(w.DO.Omit(cols...))
}

func (w wfTicketflowDo) Join(table schema.Tabler, on ...field.Expr) IWfTicketflowDo {
	return w.withDO(w.DO.Join(table, on...))
}

func (w wfTicketflowDo) LeftJoin(table schema.Tabler, on ...field.Expr) IWfTicketflowDo {
	return w.withDO(w.DO.LeftJoin(table, on...))
}

func (w wfTicketflowDo) RightJoin(table schema.Tabler, on ...field.Expr) IWfTicketflowDo {
	return w.withDO(w.DO.RightJoin(table, on...))
}

func (w wfTicketflowDo) Group(cols ...field.Expr) IWfTicketflowDo {
	return w.withDO(w.DO.Group(cols...))
}

func (w wfTicketflowDo) Having(conds ...gen.Condition) IWfTicketflowDo {
	return w.withDO(w.DO.Having(conds...))
}

func (w wfTicketflowDo) Limit(limit int) IWfTicketflowDo {
	return w.withDO(w.DO.Limit(limit))
}

func (w wfTicketflowDo) Offset(offset int) IWfTicketflowDo {
	return w.withDO(w.DO.Offset(offset))
}

func (w wfTicketflowDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IWfTicketflowDo {
	return w.withDO(w.DO.Scopes(funcs...))
}

func (w wfTicketflowDo) Unscoped() IWfTicketflowDo {
	return w.withDO(w.DO.Unscoped())
}

func (w wfTicketflowDo) Create(values ...*model.WfTicketflow) error {
	if len(values) == 0 {
		return nil
	}
	return w.DO.Create(values)
}

func (w wfTicketflowDo) CreateInBatches(values []*model.WfTicketflow, batchSize int) error {
	return w.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (w wfTicketflowDo) Save(values ...*model.WfTicketflow) error {
	if len(values) == 0 {
		return nil
	}
	return w.DO.Save(values)
}

func (w wfTicketflowDo) First() (*model.WfTicketflow, error) {
	if result, err := w.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.WfTicketflow), nil
	}
}

func (w wfTicketflowDo) Take() (*model.WfTicketflow, error) {
	if result, err := w.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.WfTicketflow), nil
	}
}

func (w wfTicketflowDo) Last() (*model.WfTicketflow, error) {
	if result, err := w.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.WfTicketflow), nil
	}
}

func (w wfTicketflowDo) Find() ([]*model.WfTicketflow, error) {
	result, err := w.DO.Find()
	return result.([]*model.WfTicketflow), err
}

func (w wfTicketflowDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.WfTicketflow, err error) {
	buf := make([]*model.WfTicketflow, 0, batchSize)
	err = w.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (w wfTicketflowDo) FindInBatches(result *[]*model.WfTicketflow, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return w.DO.FindInBatches(result, batchSize, fc)
}

func (w wfTicketflowDo) Attrs(attrs ...field.AssignExpr) IWfTicketflowDo {
	return w.withDO(w.DO.Attrs(attrs...))
}

func (w wfTicketflowDo) Assign(attrs ...field.AssignExpr) IWfTicketflowDo {
	return w.withDO(w.DO.Assign(attrs...))
}

func (w wfTicketflowDo) Joins(fields ...field.RelationField) IWfTicketflowDo {
	for _, _f := range fields {
		w = *w.withDO(w.DO.Joins(_f))
	}
	return &w
}

func (w wfTicketflowDo) Preload(fields ...field.RelationField) IWfTicketflowDo {
	for _, _f := range fields {
		w = *w.withDO(w.DO.Preload(_f))
	}
	return &w
}

func (w wfTicketflowDo) FirstOrInit() (*model.WfTicketflow, error) {
	if result, err := w.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.WfTicketflow), nil
	}
}

func (w wfTicketflowDo) FirstOrCreate() (*model.WfTicketflow, error) {
	if result, err := w.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.WfTicketflow), nil
	}
}

func (w wfTicketflowDo) FindByPage(offset int, limit int) (result []*model.WfTicketflow, count int64, err error) {
	result, err = w.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = w.Offset(-1).Limit(-1).Count()
	return
}

func (w wfTicketflowDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = w.Count()
	if err != nil {
		return
	}

	err = w.Offset(offset).Limit(limit).Scan(result)
	return
}

func (w wfTicketflowDo) Scan(result interface{}) (err error) {
	return w.DO.Scan(result)
}

func (w wfTicketflowDo) Delete(models ...*model.WfTicketflow) (result gen.ResultInfo, err error) {
	return w.DO.Delete(models)
}

func (w *wfTicketflowDo) withDO(do gen.Dao) *wfTicketflowDo {
	w.DO = *do.(*gen.DO)
	return w
}
