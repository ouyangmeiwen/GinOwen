// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"gormgendemo/cmd/generate/dal/model"
)

func newWfTicket(db *gorm.DB) wfTicket {
	_wfTicket := wfTicket{}

	_wfTicket.wfTicketDo.UseDB(db)
	_wfTicket.wfTicketDo.UseModel(&model.WfTicket{})

	tableName := _wfTicket.wfTicketDo.TableName()
	_wfTicket.ALL = field.NewAsterisk(tableName)
	_wfTicket.ID = field.NewInt64(tableName, "id")
	_wfTicket.CreateTime = field.NewTime(tableName, "create_time")
	_wfTicket.UpdateTime = field.NewTime(tableName, "update_time")
	_wfTicket.IsDeleted = field.NewInt64(tableName, "is_deleted")
	_wfTicket.Title = field.NewString(tableName, "title")
	_wfTicket.Sn = field.NewString(tableName, "sn")
	_wfTicket.TicketData = field.NewString(tableName, "ticket_data")
	_wfTicket.InAddNode = field.NewInt64(tableName, "in_add_node")
	_wfTicket.ScriptRunLastResult = field.NewInt64(tableName, "script_run_last_result")
	_wfTicket.ParticipantType = field.NewInt64(tableName, "participant_type")
	_wfTicket.Participant = field.NewString(tableName, "participant")
	_wfTicket.ActState = field.NewInt64(tableName, "act_state")
	_wfTicket.MultiAllPerson = field.NewString(tableName, "multi_all_person")
	_wfTicket.AddNodeManID = field.NewInt64(tableName, "add_node_man_id")
	_wfTicket.BelongDeptID = field.NewInt64(tableName, "belong_dept_id")
	_wfTicket.CreateByID = field.NewInt64(tableName, "create_by_id")
	_wfTicket.ParentID = field.NewInt64(tableName, "parent_id")
	_wfTicket.ParentStateID = field.NewInt64(tableName, "parent_state_id")
	_wfTicket.StateID = field.NewInt64(tableName, "state_id")
	_wfTicket.UpdateByID = field.NewInt64(tableName, "update_by_id")
	_wfTicket.WorkflowID = field.NewInt64(tableName, "workflow_id")

	_wfTicket.fillFieldMap()

	return _wfTicket
}

type wfTicket struct {
	wfTicketDo wfTicketDo

	ALL                 field.Asterisk
	ID                  field.Int64
	CreateTime          field.Time
	UpdateTime          field.Time
	IsDeleted           field.Int64
	Title               field.String
	Sn                  field.String
	TicketData          field.String
	InAddNode           field.Int64
	ScriptRunLastResult field.Int64
	ParticipantType     field.Int64
	Participant         field.String
	ActState            field.Int64
	MultiAllPerson      field.String
	AddNodeManID        field.Int64
	BelongDeptID        field.Int64
	CreateByID          field.Int64
	ParentID            field.Int64
	ParentStateID       field.Int64
	StateID             field.Int64
	UpdateByID          field.Int64
	WorkflowID          field.Int64

	fieldMap map[string]field.Expr
}

func (w wfTicket) Table(newTableName string) *wfTicket {
	w.wfTicketDo.UseTable(newTableName)
	return w.updateTableName(newTableName)
}

func (w wfTicket) As(alias string) *wfTicket {
	w.wfTicketDo.DO = *(w.wfTicketDo.As(alias).(*gen.DO))
	return w.updateTableName(alias)
}

func (w *wfTicket) updateTableName(table string) *wfTicket {
	w.ALL = field.NewAsterisk(table)
	w.ID = field.NewInt64(table, "id")
	w.CreateTime = field.NewTime(table, "create_time")
	w.UpdateTime = field.NewTime(table, "update_time")
	w.IsDeleted = field.NewInt64(table, "is_deleted")
	w.Title = field.NewString(table, "title")
	w.Sn = field.NewString(table, "sn")
	w.TicketData = field.NewString(table, "ticket_data")
	w.InAddNode = field.NewInt64(table, "in_add_node")
	w.ScriptRunLastResult = field.NewInt64(table, "script_run_last_result")
	w.ParticipantType = field.NewInt64(table, "participant_type")
	w.Participant = field.NewString(table, "participant")
	w.ActState = field.NewInt64(table, "act_state")
	w.MultiAllPerson = field.NewString(table, "multi_all_person")
	w.AddNodeManID = field.NewInt64(table, "add_node_man_id")
	w.BelongDeptID = field.NewInt64(table, "belong_dept_id")
	w.CreateByID = field.NewInt64(table, "create_by_id")
	w.ParentID = field.NewInt64(table, "parent_id")
	w.ParentStateID = field.NewInt64(table, "parent_state_id")
	w.StateID = field.NewInt64(table, "state_id")
	w.UpdateByID = field.NewInt64(table, "update_by_id")
	w.WorkflowID = field.NewInt64(table, "workflow_id")

	w.fillFieldMap()

	return w
}

func (w *wfTicket) WithContext(ctx context.Context) IWfTicketDo { return w.wfTicketDo.WithContext(ctx) }

func (w wfTicket) TableName() string { return w.wfTicketDo.TableName() }

func (w wfTicket) Alias() string { return w.wfTicketDo.Alias() }

func (w *wfTicket) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := w.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (w *wfTicket) fillFieldMap() {
	w.fieldMap = make(map[string]field.Expr, 21)
	w.fieldMap["id"] = w.ID
	w.fieldMap["create_time"] = w.CreateTime
	w.fieldMap["update_time"] = w.UpdateTime
	w.fieldMap["is_deleted"] = w.IsDeleted
	w.fieldMap["title"] = w.Title
	w.fieldMap["sn"] = w.Sn
	w.fieldMap["ticket_data"] = w.TicketData
	w.fieldMap["in_add_node"] = w.InAddNode
	w.fieldMap["script_run_last_result"] = w.ScriptRunLastResult
	w.fieldMap["participant_type"] = w.ParticipantType
	w.fieldMap["participant"] = w.Participant
	w.fieldMap["act_state"] = w.ActState
	w.fieldMap["multi_all_person"] = w.MultiAllPerson
	w.fieldMap["add_node_man_id"] = w.AddNodeManID
	w.fieldMap["belong_dept_id"] = w.BelongDeptID
	w.fieldMap["create_by_id"] = w.CreateByID
	w.fieldMap["parent_id"] = w.ParentID
	w.fieldMap["parent_state_id"] = w.ParentStateID
	w.fieldMap["state_id"] = w.StateID
	w.fieldMap["update_by_id"] = w.UpdateByID
	w.fieldMap["workflow_id"] = w.WorkflowID
}

func (w wfTicket) clone(db *gorm.DB) wfTicket {
	w.wfTicketDo.ReplaceDB(db)
	return w
}

type wfTicketDo struct{ gen.DO }

type IWfTicketDo interface {
	gen.SubQuery
	Debug() IWfTicketDo
	WithContext(ctx context.Context) IWfTicketDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	As(alias string) gen.Dao
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IWfTicketDo
	Not(conds ...gen.Condition) IWfTicketDo
	Or(conds ...gen.Condition) IWfTicketDo
	Select(conds ...field.Expr) IWfTicketDo
	Where(conds ...gen.Condition) IWfTicketDo
	Order(conds ...field.Expr) IWfTicketDo
	Distinct(cols ...field.Expr) IWfTicketDo
	Omit(cols ...field.Expr) IWfTicketDo
	Join(table schema.Tabler, on ...field.Expr) IWfTicketDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IWfTicketDo
	RightJoin(table schema.Tabler, on ...field.Expr) IWfTicketDo
	Group(cols ...field.Expr) IWfTicketDo
	Having(conds ...gen.Condition) IWfTicketDo
	Limit(limit int) IWfTicketDo
	Offset(offset int) IWfTicketDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IWfTicketDo
	Unscoped() IWfTicketDo
	Create(values ...*model.WfTicket) error
	CreateInBatches(values []*model.WfTicket, batchSize int) error
	Save(values ...*model.WfTicket) error
	First() (*model.WfTicket, error)
	Take() (*model.WfTicket, error)
	Last() (*model.WfTicket, error)
	Find() ([]*model.WfTicket, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.WfTicket, err error)
	FindInBatches(result *[]*model.WfTicket, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.WfTicket) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IWfTicketDo
	Assign(attrs ...field.AssignExpr) IWfTicketDo
	Joins(fields ...field.RelationField) IWfTicketDo
	Preload(fields ...field.RelationField) IWfTicketDo
	FirstOrInit() (*model.WfTicket, error)
	FirstOrCreate() (*model.WfTicket, error)
	FindByPage(offset int, limit int) (result []*model.WfTicket, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IWfTicketDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (w wfTicketDo) Debug() IWfTicketDo {
	return w.withDO(w.DO.Debug())
}

func (w wfTicketDo) WithContext(ctx context.Context) IWfTicketDo {
	return w.withDO(w.DO.WithContext(ctx))
}

func (w wfTicketDo) ReadDB() IWfTicketDo {
	return w.Clauses(dbresolver.Read)
}

func (w wfTicketDo) WriteDB() IWfTicketDo {
	return w.Clauses(dbresolver.Write)
}

func (w wfTicketDo) Clauses(conds ...clause.Expression) IWfTicketDo {
	return w.withDO(w.DO.Clauses(conds...))
}

func (w wfTicketDo) Returning(value interface{}, columns ...string) IWfTicketDo {
	return w.withDO(w.DO.Returning(value, columns...))
}

func (w wfTicketDo) Not(conds ...gen.Condition) IWfTicketDo {
	return w.withDO(w.DO.Not(conds...))
}

func (w wfTicketDo) Or(conds ...gen.Condition) IWfTicketDo {
	return w.withDO(w.DO.Or(conds...))
}

func (w wfTicketDo) Select(conds ...field.Expr) IWfTicketDo {
	return w.withDO(w.DO.Select(conds...))
}

func (w wfTicketDo) Where(conds ...gen.Condition) IWfTicketDo {
	return w.withDO(w.DO.Where(conds...))
}

func (w wfTicketDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) IWfTicketDo {
	return w.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (w wfTicketDo) Order(conds ...field.Expr) IWfTicketDo {
	return w.withDO(w.DO.Order(conds...))
}

func (w wfTicketDo) Distinct(cols ...field.Expr) IWfTicketDo {
	return w.withDO(w.DO.Distinct(cols...))
}

func (w wfTicketDo) Omit(cols ...field.Expr) IWfTicketDo {
	return w.withDO(w.DO.Omit(cols...))
}

func (w wfTicketDo) Join(table schema.Tabler, on ...field.Expr) IWfTicketDo {
	return w.withDO(w.DO.Join(table, on...))
}

func (w wfTicketDo) LeftJoin(table schema.Tabler, on ...field.Expr) IWfTicketDo {
	return w.withDO(w.DO.LeftJoin(table, on...))
}

func (w wfTicketDo) RightJoin(table schema.Tabler, on ...field.Expr) IWfTicketDo {
	return w.withDO(w.DO.RightJoin(table, on...))
}

func (w wfTicketDo) Group(cols ...field.Expr) IWfTicketDo {
	return w.withDO(w.DO.Group(cols...))
}

func (w wfTicketDo) Having(conds ...gen.Condition) IWfTicketDo {
	return w.withDO(w.DO.Having(conds...))
}

func (w wfTicketDo) Limit(limit int) IWfTicketDo {
	return w.withDO(w.DO.Limit(limit))
}

func (w wfTicketDo) Offset(offset int) IWfTicketDo {
	return w.withDO(w.DO.Offset(offset))
}

func (w wfTicketDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IWfTicketDo {
	return w.withDO(w.DO.Scopes(funcs...))
}

func (w wfTicketDo) Unscoped() IWfTicketDo {
	return w.withDO(w.DO.Unscoped())
}

func (w wfTicketDo) Create(values ...*model.WfTicket) error {
	if len(values) == 0 {
		return nil
	}
	return w.DO.Create(values)
}

func (w wfTicketDo) CreateInBatches(values []*model.WfTicket, batchSize int) error {
	return w.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (w wfTicketDo) Save(values ...*model.WfTicket) error {
	if len(values) == 0 {
		return nil
	}
	return w.DO.Save(values)
}

func (w wfTicketDo) First() (*model.WfTicket, error) {
	if result, err := w.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.WfTicket), nil
	}
}

func (w wfTicketDo) Take() (*model.WfTicket, error) {
	if result, err := w.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.WfTicket), nil
	}
}

func (w wfTicketDo) Last() (*model.WfTicket, error) {
	if result, err := w.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.WfTicket), nil
	}
}

func (w wfTicketDo) Find() ([]*model.WfTicket, error) {
	result, err := w.DO.Find()
	return result.([]*model.WfTicket), err
}

func (w wfTicketDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.WfTicket, err error) {
	buf := make([]*model.WfTicket, 0, batchSize)
	err = w.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (w wfTicketDo) FindInBatches(result *[]*model.WfTicket, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return w.DO.FindInBatches(result, batchSize, fc)
}

func (w wfTicketDo) Attrs(attrs ...field.AssignExpr) IWfTicketDo {
	return w.withDO(w.DO.Attrs(attrs...))
}

func (w wfTicketDo) Assign(attrs ...field.AssignExpr) IWfTicketDo {
	return w.withDO(w.DO.Assign(attrs...))
}

func (w wfTicketDo) Joins(fields ...field.RelationField) IWfTicketDo {
	for _, _f := range fields {
		w = *w.withDO(w.DO.Joins(_f))
	}
	return &w
}

func (w wfTicketDo) Preload(fields ...field.RelationField) IWfTicketDo {
	for _, _f := range fields {
		w = *w.withDO(w.DO.Preload(_f))
	}
	return &w
}

func (w wfTicketDo) FirstOrInit() (*model.WfTicket, error) {
	if result, err := w.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.WfTicket), nil
	}
}

func (w wfTicketDo) FirstOrCreate() (*model.WfTicket, error) {
	if result, err := w.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.WfTicket), nil
	}
}

func (w wfTicketDo) FindByPage(offset int, limit int) (result []*model.WfTicket, count int64, err error) {
	result, err = w.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = w.Offset(-1).Limit(-1).Count()
	return
}

func (w wfTicketDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = w.Count()
	if err != nil {
		return
	}

	err = w.Offset(offset).Limit(limit).Scan(result)
	return
}

func (w wfTicketDo) Scan(result interface{}) (err error) {
	return w.DO.Scan(result)
}

func (w wfTicketDo) Delete(models ...*model.WfTicket) (result gen.ResultInfo, err error) {
	return w.DO.Delete(models)
}

func (w *wfTicketDo) withDO(do gen.Dao) *wfTicketDo {
	w.DO = *do.(*gen.DO)
	return w
}
