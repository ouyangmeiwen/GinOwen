// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"gormgendemo/cmd/generate/dal/model"
)

func newDjangoCeleryBeatPeriodictask(db *gorm.DB) djangoCeleryBeatPeriodictask {
	_djangoCeleryBeatPeriodictask := djangoCeleryBeatPeriodictask{}

	_djangoCeleryBeatPeriodictask.djangoCeleryBeatPeriodictaskDo.UseDB(db)
	_djangoCeleryBeatPeriodictask.djangoCeleryBeatPeriodictaskDo.UseModel(&model.DjangoCeleryBeatPeriodictask{})

	tableName := _djangoCeleryBeatPeriodictask.djangoCeleryBeatPeriodictaskDo.TableName()
	_djangoCeleryBeatPeriodictask.ALL = field.NewAsterisk(tableName)
	_djangoCeleryBeatPeriodictask.ID = field.NewInt64(tableName, "id")
	_djangoCeleryBeatPeriodictask.Name = field.NewString(tableName, "name")
	_djangoCeleryBeatPeriodictask.Task = field.NewString(tableName, "task")
	_djangoCeleryBeatPeriodictask.Args = field.NewString(tableName, "args")
	_djangoCeleryBeatPeriodictask.Kwargs = field.NewString(tableName, "kwargs")
	_djangoCeleryBeatPeriodictask.Queue = field.NewString(tableName, "queue")
	_djangoCeleryBeatPeriodictask.Exchange = field.NewString(tableName, "exchange")
	_djangoCeleryBeatPeriodictask.RoutingKey = field.NewString(tableName, "routing_key")
	_djangoCeleryBeatPeriodictask.Expires = field.NewTime(tableName, "expires")
	_djangoCeleryBeatPeriodictask.Enabled = field.NewInt64(tableName, "enabled")
	_djangoCeleryBeatPeriodictask.LastRunAt = field.NewTime(tableName, "last_run_at")
	_djangoCeleryBeatPeriodictask.TotalRunCount = field.NewInt64(tableName, "total_run_count")
	_djangoCeleryBeatPeriodictask.DateChanged = field.NewTime(tableName, "date_changed")
	_djangoCeleryBeatPeriodictask.Description = field.NewString(tableName, "description")
	_djangoCeleryBeatPeriodictask.CrontabID = field.NewInt64(tableName, "crontab_id")
	_djangoCeleryBeatPeriodictask.IntervalID = field.NewInt64(tableName, "interval_id")
	_djangoCeleryBeatPeriodictask.SolarID = field.NewInt64(tableName, "solar_id")
	_djangoCeleryBeatPeriodictask.OneOff = field.NewInt64(tableName, "one_off")
	_djangoCeleryBeatPeriodictask.StartTime = field.NewTime(tableName, "start_time")
	_djangoCeleryBeatPeriodictask.Priority = field.NewInt64(tableName, "priority")
	_djangoCeleryBeatPeriodictask.Headers = field.NewString(tableName, "headers")
	_djangoCeleryBeatPeriodictask.ClockedID = field.NewInt64(tableName, "clocked_id")
	_djangoCeleryBeatPeriodictask.ExpireSeconds = field.NewInt64(tableName, "expire_seconds")

	_djangoCeleryBeatPeriodictask.fillFieldMap()

	return _djangoCeleryBeatPeriodictask
}

type djangoCeleryBeatPeriodictask struct {
	djangoCeleryBeatPeriodictaskDo djangoCeleryBeatPeriodictaskDo

	ALL           field.Asterisk
	ID            field.Int64
	Name          field.String
	Task          field.String
	Args          field.String
	Kwargs        field.String
	Queue         field.String
	Exchange      field.String
	RoutingKey    field.String
	Expires       field.Time
	Enabled       field.Int64
	LastRunAt     field.Time
	TotalRunCount field.Int64
	DateChanged   field.Time
	Description   field.String
	CrontabID     field.Int64
	IntervalID    field.Int64
	SolarID       field.Int64
	OneOff        field.Int64
	StartTime     field.Time
	Priority      field.Int64
	Headers       field.String
	ClockedID     field.Int64
	ExpireSeconds field.Int64

	fieldMap map[string]field.Expr
}

func (d djangoCeleryBeatPeriodictask) Table(newTableName string) *djangoCeleryBeatPeriodictask {
	d.djangoCeleryBeatPeriodictaskDo.UseTable(newTableName)
	return d.updateTableName(newTableName)
}

func (d djangoCeleryBeatPeriodictask) As(alias string) *djangoCeleryBeatPeriodictask {
	d.djangoCeleryBeatPeriodictaskDo.DO = *(d.djangoCeleryBeatPeriodictaskDo.As(alias).(*gen.DO))
	return d.updateTableName(alias)
}

func (d *djangoCeleryBeatPeriodictask) updateTableName(table string) *djangoCeleryBeatPeriodictask {
	d.ALL = field.NewAsterisk(table)
	d.ID = field.NewInt64(table, "id")
	d.Name = field.NewString(table, "name")
	d.Task = field.NewString(table, "task")
	d.Args = field.NewString(table, "args")
	d.Kwargs = field.NewString(table, "kwargs")
	d.Queue = field.NewString(table, "queue")
	d.Exchange = field.NewString(table, "exchange")
	d.RoutingKey = field.NewString(table, "routing_key")
	d.Expires = field.NewTime(table, "expires")
	d.Enabled = field.NewInt64(table, "enabled")
	d.LastRunAt = field.NewTime(table, "last_run_at")
	d.TotalRunCount = field.NewInt64(table, "total_run_count")
	d.DateChanged = field.NewTime(table, "date_changed")
	d.Description = field.NewString(table, "description")
	d.CrontabID = field.NewInt64(table, "crontab_id")
	d.IntervalID = field.NewInt64(table, "interval_id")
	d.SolarID = field.NewInt64(table, "solar_id")
	d.OneOff = field.NewInt64(table, "one_off")
	d.StartTime = field.NewTime(table, "start_time")
	d.Priority = field.NewInt64(table, "priority")
	d.Headers = field.NewString(table, "headers")
	d.ClockedID = field.NewInt64(table, "clocked_id")
	d.ExpireSeconds = field.NewInt64(table, "expire_seconds")

	d.fillFieldMap()

	return d
}

func (d *djangoCeleryBeatPeriodictask) WithContext(ctx context.Context) IDjangoCeleryBeatPeriodictaskDo {
	return d.djangoCeleryBeatPeriodictaskDo.WithContext(ctx)
}

func (d djangoCeleryBeatPeriodictask) TableName() string {
	return d.djangoCeleryBeatPeriodictaskDo.TableName()
}

func (d djangoCeleryBeatPeriodictask) Alias() string { return d.djangoCeleryBeatPeriodictaskDo.Alias() }

func (d *djangoCeleryBeatPeriodictask) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := d.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (d *djangoCeleryBeatPeriodictask) fillFieldMap() {
	d.fieldMap = make(map[string]field.Expr, 23)
	d.fieldMap["id"] = d.ID
	d.fieldMap["name"] = d.Name
	d.fieldMap["task"] = d.Task
	d.fieldMap["args"] = d.Args
	d.fieldMap["kwargs"] = d.Kwargs
	d.fieldMap["queue"] = d.Queue
	d.fieldMap["exchange"] = d.Exchange
	d.fieldMap["routing_key"] = d.RoutingKey
	d.fieldMap["expires"] = d.Expires
	d.fieldMap["enabled"] = d.Enabled
	d.fieldMap["last_run_at"] = d.LastRunAt
	d.fieldMap["total_run_count"] = d.TotalRunCount
	d.fieldMap["date_changed"] = d.DateChanged
	d.fieldMap["description"] = d.Description
	d.fieldMap["crontab_id"] = d.CrontabID
	d.fieldMap["interval_id"] = d.IntervalID
	d.fieldMap["solar_id"] = d.SolarID
	d.fieldMap["one_off"] = d.OneOff
	d.fieldMap["start_time"] = d.StartTime
	d.fieldMap["priority"] = d.Priority
	d.fieldMap["headers"] = d.Headers
	d.fieldMap["clocked_id"] = d.ClockedID
	d.fieldMap["expire_seconds"] = d.ExpireSeconds
}

func (d djangoCeleryBeatPeriodictask) clone(db *gorm.DB) djangoCeleryBeatPeriodictask {
	d.djangoCeleryBeatPeriodictaskDo.ReplaceDB(db)
	return d
}

type djangoCeleryBeatPeriodictaskDo struct{ gen.DO }

type IDjangoCeleryBeatPeriodictaskDo interface {
	gen.SubQuery
	Debug() IDjangoCeleryBeatPeriodictaskDo
	WithContext(ctx context.Context) IDjangoCeleryBeatPeriodictaskDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	As(alias string) gen.Dao
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IDjangoCeleryBeatPeriodictaskDo
	Not(conds ...gen.Condition) IDjangoCeleryBeatPeriodictaskDo
	Or(conds ...gen.Condition) IDjangoCeleryBeatPeriodictaskDo
	Select(conds ...field.Expr) IDjangoCeleryBeatPeriodictaskDo
	Where(conds ...gen.Condition) IDjangoCeleryBeatPeriodictaskDo
	Order(conds ...field.Expr) IDjangoCeleryBeatPeriodictaskDo
	Distinct(cols ...field.Expr) IDjangoCeleryBeatPeriodictaskDo
	Omit(cols ...field.Expr) IDjangoCeleryBeatPeriodictaskDo
	Join(table schema.Tabler, on ...field.Expr) IDjangoCeleryBeatPeriodictaskDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IDjangoCeleryBeatPeriodictaskDo
	RightJoin(table schema.Tabler, on ...field.Expr) IDjangoCeleryBeatPeriodictaskDo
	Group(cols ...field.Expr) IDjangoCeleryBeatPeriodictaskDo
	Having(conds ...gen.Condition) IDjangoCeleryBeatPeriodictaskDo
	Limit(limit int) IDjangoCeleryBeatPeriodictaskDo
	Offset(offset int) IDjangoCeleryBeatPeriodictaskDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IDjangoCeleryBeatPeriodictaskDo
	Unscoped() IDjangoCeleryBeatPeriodictaskDo
	Create(values ...*model.DjangoCeleryBeatPeriodictask) error
	CreateInBatches(values []*model.DjangoCeleryBeatPeriodictask, batchSize int) error
	Save(values ...*model.DjangoCeleryBeatPeriodictask) error
	First() (*model.DjangoCeleryBeatPeriodictask, error)
	Take() (*model.DjangoCeleryBeatPeriodictask, error)
	Last() (*model.DjangoCeleryBeatPeriodictask, error)
	Find() ([]*model.DjangoCeleryBeatPeriodictask, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.DjangoCeleryBeatPeriodictask, err error)
	FindInBatches(result *[]*model.DjangoCeleryBeatPeriodictask, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.DjangoCeleryBeatPeriodictask) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IDjangoCeleryBeatPeriodictaskDo
	Assign(attrs ...field.AssignExpr) IDjangoCeleryBeatPeriodictaskDo
	Joins(fields ...field.RelationField) IDjangoCeleryBeatPeriodictaskDo
	Preload(fields ...field.RelationField) IDjangoCeleryBeatPeriodictaskDo
	FirstOrInit() (*model.DjangoCeleryBeatPeriodictask, error)
	FirstOrCreate() (*model.DjangoCeleryBeatPeriodictask, error)
	FindByPage(offset int, limit int) (result []*model.DjangoCeleryBeatPeriodictask, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IDjangoCeleryBeatPeriodictaskDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (d djangoCeleryBeatPeriodictaskDo) Debug() IDjangoCeleryBeatPeriodictaskDo {
	return d.withDO(d.DO.Debug())
}

func (d djangoCeleryBeatPeriodictaskDo) WithContext(ctx context.Context) IDjangoCeleryBeatPeriodictaskDo {
	return d.withDO(d.DO.WithContext(ctx))
}

func (d djangoCeleryBeatPeriodictaskDo) ReadDB() IDjangoCeleryBeatPeriodictaskDo {
	return d.Clauses(dbresolver.Read)
}

func (d djangoCeleryBeatPeriodictaskDo) WriteDB() IDjangoCeleryBeatPeriodictaskDo {
	return d.Clauses(dbresolver.Write)
}

func (d djangoCeleryBeatPeriodictaskDo) Clauses(conds ...clause.Expression) IDjangoCeleryBeatPeriodictaskDo {
	return d.withDO(d.DO.Clauses(conds...))
}

func (d djangoCeleryBeatPeriodictaskDo) Returning(value interface{}, columns ...string) IDjangoCeleryBeatPeriodictaskDo {
	return d.withDO(d.DO.Returning(value, columns...))
}

func (d djangoCeleryBeatPeriodictaskDo) Not(conds ...gen.Condition) IDjangoCeleryBeatPeriodictaskDo {
	return d.withDO(d.DO.Not(conds...))
}

func (d djangoCeleryBeatPeriodictaskDo) Or(conds ...gen.Condition) IDjangoCeleryBeatPeriodictaskDo {
	return d.withDO(d.DO.Or(conds...))
}

func (d djangoCeleryBeatPeriodictaskDo) Select(conds ...field.Expr) IDjangoCeleryBeatPeriodictaskDo {
	return d.withDO(d.DO.Select(conds...))
}

func (d djangoCeleryBeatPeriodictaskDo) Where(conds ...gen.Condition) IDjangoCeleryBeatPeriodictaskDo {
	return d.withDO(d.DO.Where(conds...))
}

func (d djangoCeleryBeatPeriodictaskDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) IDjangoCeleryBeatPeriodictaskDo {
	return d.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (d djangoCeleryBeatPeriodictaskDo) Order(conds ...field.Expr) IDjangoCeleryBeatPeriodictaskDo {
	return d.withDO(d.DO.Order(conds...))
}

func (d djangoCeleryBeatPeriodictaskDo) Distinct(cols ...field.Expr) IDjangoCeleryBeatPeriodictaskDo {
	return d.withDO(d.DO.Distinct(cols...))
}

func (d djangoCeleryBeatPeriodictaskDo) Omit(cols ...field.Expr) IDjangoCeleryBeatPeriodictaskDo {
	return d.withDO(d.DO.Omit(cols...))
}

func (d djangoCeleryBeatPeriodictaskDo) Join(table schema.Tabler, on ...field.Expr) IDjangoCeleryBeatPeriodictaskDo {
	return d.withDO(d.DO.Join(table, on...))
}

func (d djangoCeleryBeatPeriodictaskDo) LeftJoin(table schema.Tabler, on ...field.Expr) IDjangoCeleryBeatPeriodictaskDo {
	return d.withDO(d.DO.LeftJoin(table, on...))
}

func (d djangoCeleryBeatPeriodictaskDo) RightJoin(table schema.Tabler, on ...field.Expr) IDjangoCeleryBeatPeriodictaskDo {
	return d.withDO(d.DO.RightJoin(table, on...))
}

func (d djangoCeleryBeatPeriodictaskDo) Group(cols ...field.Expr) IDjangoCeleryBeatPeriodictaskDo {
	return d.withDO(d.DO.Group(cols...))
}

func (d djangoCeleryBeatPeriodictaskDo) Having(conds ...gen.Condition) IDjangoCeleryBeatPeriodictaskDo {
	return d.withDO(d.DO.Having(conds...))
}

func (d djangoCeleryBeatPeriodictaskDo) Limit(limit int) IDjangoCeleryBeatPeriodictaskDo {
	return d.withDO(d.DO.Limit(limit))
}

func (d djangoCeleryBeatPeriodictaskDo) Offset(offset int) IDjangoCeleryBeatPeriodictaskDo {
	return d.withDO(d.DO.Offset(offset))
}

func (d djangoCeleryBeatPeriodictaskDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IDjangoCeleryBeatPeriodictaskDo {
	return d.withDO(d.DO.Scopes(funcs...))
}

func (d djangoCeleryBeatPeriodictaskDo) Unscoped() IDjangoCeleryBeatPeriodictaskDo {
	return d.withDO(d.DO.Unscoped())
}

func (d djangoCeleryBeatPeriodictaskDo) Create(values ...*model.DjangoCeleryBeatPeriodictask) error {
	if len(values) == 0 {
		return nil
	}
	return d.DO.Create(values)
}

func (d djangoCeleryBeatPeriodictaskDo) CreateInBatches(values []*model.DjangoCeleryBeatPeriodictask, batchSize int) error {
	return d.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (d djangoCeleryBeatPeriodictaskDo) Save(values ...*model.DjangoCeleryBeatPeriodictask) error {
	if len(values) == 0 {
		return nil
	}
	return d.DO.Save(values)
}

func (d djangoCeleryBeatPeriodictaskDo) First() (*model.DjangoCeleryBeatPeriodictask, error) {
	if result, err := d.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.DjangoCeleryBeatPeriodictask), nil
	}
}

func (d djangoCeleryBeatPeriodictaskDo) Take() (*model.DjangoCeleryBeatPeriodictask, error) {
	if result, err := d.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.DjangoCeleryBeatPeriodictask), nil
	}
}

func (d djangoCeleryBeatPeriodictaskDo) Last() (*model.DjangoCeleryBeatPeriodictask, error) {
	if result, err := d.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.DjangoCeleryBeatPeriodictask), nil
	}
}

func (d djangoCeleryBeatPeriodictaskDo) Find() ([]*model.DjangoCeleryBeatPeriodictask, error) {
	result, err := d.DO.Find()
	return result.([]*model.DjangoCeleryBeatPeriodictask), err
}

func (d djangoCeleryBeatPeriodictaskDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.DjangoCeleryBeatPeriodictask, err error) {
	buf := make([]*model.DjangoCeleryBeatPeriodictask, 0, batchSize)
	err = d.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (d djangoCeleryBeatPeriodictaskDo) FindInBatches(result *[]*model.DjangoCeleryBeatPeriodictask, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return d.DO.FindInBatches(result, batchSize, fc)
}

func (d djangoCeleryBeatPeriodictaskDo) Attrs(attrs ...field.AssignExpr) IDjangoCeleryBeatPeriodictaskDo {
	return d.withDO(d.DO.Attrs(attrs...))
}

func (d djangoCeleryBeatPeriodictaskDo) Assign(attrs ...field.AssignExpr) IDjangoCeleryBeatPeriodictaskDo {
	return d.withDO(d.DO.Assign(attrs...))
}

func (d djangoCeleryBeatPeriodictaskDo) Joins(fields ...field.RelationField) IDjangoCeleryBeatPeriodictaskDo {
	for _, _f := range fields {
		d = *d.withDO(d.DO.Joins(_f))
	}
	return &d
}

func (d djangoCeleryBeatPeriodictaskDo) Preload(fields ...field.RelationField) IDjangoCeleryBeatPeriodictaskDo {
	for _, _f := range fields {
		d = *d.withDO(d.DO.Preload(_f))
	}
	return &d
}

func (d djangoCeleryBeatPeriodictaskDo) FirstOrInit() (*model.DjangoCeleryBeatPeriodictask, error) {
	if result, err := d.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.DjangoCeleryBeatPeriodictask), nil
	}
}

func (d djangoCeleryBeatPeriodictaskDo) FirstOrCreate() (*model.DjangoCeleryBeatPeriodictask, error) {
	if result, err := d.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.DjangoCeleryBeatPeriodictask), nil
	}
}

func (d djangoCeleryBeatPeriodictaskDo) FindByPage(offset int, limit int) (result []*model.DjangoCeleryBeatPeriodictask, count int64, err error) {
	result, err = d.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = d.Offset(-1).Limit(-1).Count()
	return
}

func (d djangoCeleryBeatPeriodictaskDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = d.Count()
	if err != nil {
		return
	}

	err = d.Offset(offset).Limit(limit).Scan(result)
	return
}

func (d djangoCeleryBeatPeriodictaskDo) Scan(result interface{}) (err error) {
	return d.DO.Scan(result)
}

func (d djangoCeleryBeatPeriodictaskDo) Delete(models ...*model.DjangoCeleryBeatPeriodictask) (result gen.ResultInfo, err error) {
	return d.DO.Delete(models)
}

func (d *djangoCeleryBeatPeriodictaskDo) withDO(do gen.Dao) *djangoCeleryBeatPeriodictaskDo {
	d.DO = *do.(*gen.DO)
	return d
}
